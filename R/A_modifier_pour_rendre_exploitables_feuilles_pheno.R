#### Globalmatrix modifié et adapté à la situation.
## COMPRESSION DES SPECTRES EN UNE MATRICE ##

# nettoyage des variables de l'espace de travail
rm(list = ls())

source('C:/Users/avitvale/Documents/signeG/Script_R_2020/adj_asd.R')
source('C:/Users/avitvale/Documents/signeG/Script_R_2020/asd_read.R')
source('C:/Users/avitvale/Documents/signeG/Script_R_2020/SIGNE_load.R')

# source('C:/Users/avitvale/Documents/Script_R/SIGNE_load.R')       ##### N'arrive pas à trouver le chemin "normal (dans signeG), comprends pas pourquoi
# source('C:/Users/avitvale/Documents/Script_R/adj_asd.R')
# source('C:/Users/avitvale/Documents/Script_R/asd_read.R')


# #création de la matrice qui rassemble tous les dossiers:
globalmatrix=matrix(ncol=2072)

setwd("C:/Users/avitvale/Documents/SIGNE/Prediction_pheno/Feuilles")
  for (n in 1:length(dir())){
      lieu="B"
      for (m in 1:length(dir())){
          em=paste(dir()[m], sep="")
          w=SIGNE_load(em)
          rownames(w)=paste(dir()[m],rownames(w),lieu) #On ajoute l'identifiant lieu au nom de chaque spectre
          globalmatrix=rbind(globalmatrix, w)
      }
}




globalmatrix=globalmatrix[complete.cases(globalmatrix),]
#str(globalmatrix)

rownames(globalmatrix)





# ## Filtrage des spectres aberrants        #Tous les spectres aberrants sont-ils filtrés par ce moyen ?
# globalmatrix2=globalmatrix[globalmatrix[,500]>0.6,] #Actuellement, 33 spectres jugés aberrants filtrés ici. (Dont 5 qui ne font pas partie de nos 10 clones étudiés..?)
# globalmatrix2=globalmatrix2[globalmatrix2[,1]<0.2,]
# globalmatrix2=globalmatrix2[globalmatrix2[,2000]<0.25,]


## Ajustement des sauts de detecteur (Montpellier: sauts ?? 1000 (651 eme l.o.) et 1800 (1451))
globalmatrix=adj_asd(globalmatrix,c(602,1402))

## Reduction des variables (extremites bruitees)
globalmatrix=globalmatrix[,seq(51,ncol(globalmatrix)-30,1)]





# Truc=globalmatrix
#
#
#
# brb="C:/Users/avitvale/Documents/Test/"
# save(Truc, file=paste(brb,"Truc",sep=""))
# print(length(Truc))
# # write.table(globalmatrix, file=paste(brb,"globalmatrix.csv",sep=""),sep=";", quote=FALSE)
# setwd("C:/Users/avitvale/Documents/signeG")
# ### END ###


# gsub sert à remplacer un groupe de caractères par un autre dans une liste.
# gsub("A remplacer","Remplacement", Liste)

length(rownames(globalmatrix))

rownames(globalmatrix)[-grep("[0-9]{8}(N|T) ([0-9]+|[A-Z|a-z]+) ?[0-9]{0,3} ?[0-9]{0,3}-[0-9]{2,3} B", rownames(globalmatrix))]
rownames(globalmatrix)[-grep("[0-9]{8}(N|T) ([0-9]+|[A-Z|a-z]+) [0-9]{0,3} ?[0-9]{0,3}-[0-9]{2} B", rownames(globalmatrix))]




rownames(globalmatrix)=sub("--", "-0", rownames(globalmatrix))

anomalies=grep("[0-9]{8}(N|T) ([0-9]+|[A-Z|a-z]+) ?[0-9]{0,3} ?[0-9]{0,3}-00[0-9]{2} B", rownames(globalmatrix)) #Zéros en trop dans le code d'identification individu
rownames(globalmatrix)[anomalies]=sub("-00", "-", rownames(globalmatrix)[anomalies])

anomalies=-grep("[0-9]{8}(N|T) ([0-9]+|[A-Z|a-z]+) ?[0-9]{0,3} ?[0-9]{0,3}-[0-9]{2,3} B", rownames(globalmatrix)) #Espace devant le "-"
rownames(globalmatrix)[anomalies]=sub(" -", "-", rownames(globalmatrix)[anomalies])

anomalies=grep("[0-9]{8}(N|T) ([0-9]+|[A-Z|a-z]+) ?[0-9]{0,3} ?[0-9]{0,3}-[0-9]{3} B", rownames(globalmatrix))
rownames(globalmatrix)[anomalies]=sub("-0", "-", rownames(globalmatrix)[anomalies])








indetermines=-grep("[0-9]{8}(N|T) ([0-9]+|[A-Z|a-z]+) ?[0-9]{0,3} ?[0-9]{1,3}-[0-9]{2} B", rownames(globalmatrix)) #La question à 9 millions : qui sont-ce ?

rownames(globalmatrix)[-indetermines][-grep("[0-9]{8}(N|T) ([0-9]+|[A-Z|a-z]+) [0-9]{1,3} [0-9]{1,3}-[0-9]{2} B", rownames(globalmatrix)[-indetermines])]

relous=grep("(2153)|(787)", rownames(globalmatrix)[-indetermines]) #Contient des chiffres là où tous les autres contiennent des lettres + autres anomalies.

rownames(globalmatrix)[-indetermines][-relous][-grep("[0-9]{8}(N|T) ([A-Z|a-z]+) ?[0-9]{1,3} ?[0-9]{1,3}-[0-9]{2} B", rownames(globalmatrix)[-indetermines][-relous])]


### J'en suis là.

sprintf("%05.2f",1)
sprintf("%05d",1)




rownames(globalmatrix)[grep("[0-9]{8}(N|T) ([0-9]+|[A-Z|a-z]+) ?[0-9]{0,3} ?[0-9]{0,3}-00[0-9]{2} B", rownames(globalmatrix))]

sub("[0-9]{8}(N|T) ?", "", rownames(globalmatrix))
length(rownames(globalmatrix)[grep("[0-9]{8}(N|T) ", rownames(globalmatrix))])
rownames(globalmatrix)[-grep("[0-9]{8}(N|T) [A-Z]* ", rownames(globalmatrix))]


sp=cbind(code.champ=as.numeric(sub("\\-.*", "", rownames(sp))), plante=sub(".*-", "", rownames(sp)),sp)



sp$plante=as.factor(trimws(gsub("\\(1\\)","",sp$plante)))



sp=cbind(sp,left_join(sp,md,by ="code.champ")[,4:9])



mono=sp[grep("monogénotype",sp$culture),]





















grep("[a-z]", letters)

txt <- c("arm","foot","lefroo", "bafoobar")
if(length(i <- grep("foo", txt)))
  cat("'foo' appears at least once in\n\t", txt, "\n")
i # 2 and 4
txt[i]

## Double all 'a' or 'b's;  "\" must be escaped, i.e., 'doubled'
gsub("([ab])", "\\1_\\1_", "abc and ABC")

txt <- c("The", "licenses", "for", "most", "software", "are",
         "designed", "to", "take", "away", "your", "freedom",
         "to", "share", "and", "change", "it.",
         "", "By", "contrast,", "the", "GNU", "General", "Public", "License",
         "is", "intended", "to", "guarantee", "your", "freedom", "to",
         "share", "and", "change", "free", "software", "--",
         "to", "make", "sure", "the", "software", "is",
         "free", "for", "all", "its", "users")
( i <- grep("[gu]", txt) ) # indices
stopifnot( txt[i] == grep("[gu]", txt, value = TRUE) )

## Note that in locales such as en_US this includes B as the
## collation order is aAbBcCdDe ...
(ot <- sub("[b-e]",".", txt))
txt[ot != gsub("[b-e]",".", txt)]#- gsub does "global" substitution

txt[gsub("g","#", txt) !=
      gsub("g","#", txt, ignore.case = TRUE)] # the "G" words

regexpr("en", txt)

gregexpr("e", txt)

## Using grepl() for filtering
## Find functions with argument names matching "warn":
findArgs <- function(env, pattern) {
  nms <- ls(envir = as.environment(env))
  nms <- nms[is.na(match(nms, c("F","T")))] # <-- work around "checking hack"
  aa <- sapply(nms, function(.) { o <- get(.)
  if(is.function(o)) names(formals(o)) })
  iw <- sapply(aa, function(a) any(grepl(pattern, a, ignore.case=TRUE)))
  aa[iw]
}
findArgs("package:base", "warn")

## trim trailing white space
str <- "Now is the time      "
sub(" +$", "", str)  ## spaces only
## what is considered 'white space' depends on the locale.
sub("[[:space:]]+$", "", str) ## white space, POSIX-style
## what PCRE considered white space changed in version 8.34: see ?regex
sub("\\s+$", "", str, perl = TRUE) ## PCRE-style white space

## capitalizing
txt <- "a test of capitalizing"
gsub("(\\w)(\\w*)", "\\U\\1\\L\\2", txt, perl=TRUE)


sub("(\\w)(\\w*)", "", rownames(globalmatrix))

gsub("\\b(\\w)",    "\\U\\1",       txt, perl=TRUE)

txt2 <- "useRs may fly into JFK or laGuardia"
gsub("(\\w)(\\w*)(\\w)", "\\U\\1\\E\\2\\U\\3", txt2, perl=TRUE)
sub("(\\w)(\\w*)(\\w)", "\\U\\1\\E\\2\\U\\3", txt2, perl=TRUE)

## named capture
notables <- c("  Ben Franklin and Jefferson Davis",
              "\tMillard Fillmore")
# name groups 'first' and 'last'
name.rex <- "(?<first>[[:upper:]][[:lower:]]+) (?<last>[[:upper:]][[:lower:]]+)"
(parsed <- regexpr(name.rex, notables, perl = TRUE))
gregexpr(name.rex, notables, perl = TRUE)[[2]]
parse.one <- function(res, result) {
  m <- do.call(rbind, lapply(seq_along(res), function(i) {
    if(result[i] == -1) return("")
    st <- attr(result, "capture.start")[i, ]
    substring(res[i], st, st + attr(result, "capture.length")[i, ] - 1)
  }))
  colnames(m) <- attr(result, "capture.names")
  m
}
parse.one(notables, parsed)

## Decompose a URL into its components.
## Example by LT (http://www.cs.uiowa.edu/~luke/R/regexp.html).
x <- "http://stat.umn.edu:80/xyz"
m <- regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)", x)
m
regmatches(x, m)
## Element 3 is the protocol, 4 is the host, 6 is the port, and 7
## is the path.  We can use this to make a function for extracting the
## parts of a URL:
URL_parts <- function(x) {
  m <- regexec("^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)", x)
  parts <- do.call(rbind,
                   lapply(regmatches(x, m), `[`, c(3L, 4L, 6L, 7L)))
  colnames(parts) <- c("protocol","host","port","path")
  parts
}
URL_parts(x)

## There is no gregexec() yet, but one can emulate it by running
## regexec() on the regmatches obtained via gregexpr().  E.g.:
pattern <- "([[:alpha:]]+)([[:digit:]]+)"
s <- "Test: A1 BC23 DEF456"
lapply(regmatches(s, gregexpr(pattern, s)),
       function(e) regmatches(e, regexec(pattern, e)))












