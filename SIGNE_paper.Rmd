---
title: "SIGNE_paper"
output: html_document
---

Load libraries
```{r setup, include=FALSE}
library(MASS)
library(FactoMineR)
library(signal)
library(plyr)
# library(caret)
library(dplyr)
library(prospectr)
# library(sampling)
library(rnirs)
library(nirsextra)
library(ggplot2)
library(plotly)
library("cowplot")
# library("gridGraphics")
library(MetStaT)

source('Script_R_2020/adj_asd.R')
source('Script_R_2020/SIGNE_load.R')
source('Script_R_2020/SIGNE_maha0.R')
source("Script_R_2020/sp2dfclo.R")
```

Load globalmatix
```{r}
brb3="/home/ecarnot/Documents/INRA/Projets/SIGNE/2019/globalmatrix"
load(file=brb3)
sp=globalmatrix
```

Set parameters
```{r}
# Savitsky-Golay parameters (p=degree of polynom, n= window size, m=derivation order)
p=2
n=11
m=1
```

Pretreatments
```{r}
## Remove gaps from 3 sub-spectrometers (Montpellier: 1000nm (#651) et 1800nm (#1451))
sp_pre=adj_asd(sp,c(276,676)) #Retrouvé empiriquement, ne correspondait pas à ce qui etait indiqué precedemment.

## SNV
sp_pre=t(scale(t(sp_pre)))

##Savitsky Golay Derivation
sp=savitzkyGolay(sp_pre, m = m, p = p, w = n)

# sp=sp[,-(665:695)] #Coupure du spectre autour des résidus de sauts de detecteurs. Ne semble pas encore effacer completement les sauts.
# sp=sp[,-(250:280)]

```


Creaction of the factors
```{r}
class=as.factor(substr(rownames(sp),9,9)) #9,9
classclo=as.factor(substr(rownames(sp),9,13)) #9,13

## Variable qui mesure le nombre de classes
c=length(levels(class))
cclo=length(levels(classclo))


# On créé un facteur datclone qui groupe un clone à 1 date
datclone=substr(rownames(sp),1,13)
ndc=length(unique(datclone))
# On créé un facteur souche qui groupe les 6 spectres de chaque souche
numsp=as.numeric(substr(rownames(sp),15,16))
souche=cut(numsp, breaks = c(0,6,12,18),labels=c("s1","s2","s3"))
endroit=as.numeric(substr(rownames(sp),15,16))%%3
rownames(sp)=paste(rownames(sp),souche,endroit)

sp=sp2dfclo(sp,class,classclo)
sp=cbind(sp,datclone,souche)

sp$cep=as.numeric(as.factor(sp$y1))
sp$clo=as.numeric(as.factor(sp$y2))
sp=sp[,-c(1,2)]
sp$annee=as.numeric(as.factor(substr(rownames(sp),1,4)))
sp$parcelle=as.numeric(as.factor(substr(rownames(sp),18,18)))
sp$position=as.numeric(as.factor(substr(rownames(sp),23,23)))
sp$jour=as.numeric(as.factor(substr(rownames(sp),1,8)))
sp$mois=as.numeric(as.factor(substr(rownames(sp),5,6)))
```

ASCA
```{r}
## Choix ici du sous-ensemble auquel on applique ASCA (si on le fait sur toutes les données, sauter cette étape)
sp=sp[which(sp$parcelle==4),] #G
sp=sp[which(sp$y1==1),]

# <!-- splevels=data.frame(cepage=as.numeric(sp$y1), annee=as.numeric(sp$annee), parcelle=as.numeric(sp$parcelle), position=as.numeric(sp$position), souche=as.numeric(sp$souche) ) -->
# 
# <!-- name_fact=c("cep","clo","souche","annee","parcelle","position","mois") -->
name_fact=c("cep","clo","annee","parcelle")

# <!-- fact=matrix(cbind(sp[,1],sp[,2],sp[,5],sp[,6],sp[,7],sp[,8],sp[,10]), ncol=7) # 1:cépage. 2:clone. 3:souche. 4:année. 5:parcelle. 6:position. 7:mois. -->
# <!-- fact=matrix(cbind(sp$cep,sp$clo,sp$souche,sp$annee,sp$parcelle,sp$position,sp$mois, ncol=7) # 1:cépage. 2:clone. 3:souche. 4:année. 5:parcelle. 6:position. 7:mois. -->

idx <- match(name_fact, names(sp))
fact=as.matrix(sp[,idx])
#fact=as.matrix(sp[,c(1,6)])

sp$xr=sp$x[,seq(1,ncol(sp$x),20)]

res=ASCA.Calculate(sp$xr, fact)

ASCA.DoPermutationTest(res)

```






